<!DOCTYPE html>
<!-- saved from url=(0053)http://playdocja.appspot.com/documentation/2.0.3/Home -->
<html class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Documentation : Home - Playframework</title>
        <link rel="stylesheet" media="screen" href="./stylesheets/main.css">
        <link rel="shortcut icon" type="image/png" href="./images/favicon.png">
                <meta name="viewport" content="width=1024, initial-scale=1">
        <script src="./javascripts/jquery-1.7.1.min.js" type="text/javascript"></script>
        <script src="./javascripts/play20.js" type="text/javascript"></script>
                <script src="./javascripts/urchin.js" type="text/javascript"></script> 
        <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script src="./javascripts/ga.js" type="text/javascript"></script>
        <script type="text/javascript">
            try {
                var pageTracker = _gat._getTracker("UA-13089827-4");
                pageTracker._trackPageview();
            } catch(err) {}
        </script>
    <link type="text/css" rel="stylesheet" charset="UTF-8" href="./stylesheets/translateelement.css"><script type="text/javascript" charset="UTF-8" src="./javascripts/main_ko.js"></script><script type="text/javascript" charset="UTF-8" src="./javascripts/element_main.js"></script></head>
    <body>
        <header>
            <a href="./index.html" id="logo"><img src="./images/logo-ja.png"></a>
            <div id="getLogo">
                <h3><font><font>Play! 로고 다운로드</font></font></h3>
                <figure>
                    <img src="./images/normal-mini.png">
                     <figcaption>
                        <a href="./images/logos/normal.png"><font><font>(png) </font></font></a>
                        <a href="./images/logos/normal.svg"><font><font>(svg)</font></font></a>
                     </figcaption>
                </figure>
                <figure>
                    <img src="./images/black-mini.png">
                     <figcaption>
                        <a href="./images/logos/black.png"><font><font>(png) </font></font></a>
                        <a href="./images/logos/black.svg"><font><font>(svg)</font></font></a>
                     </figcaption>
                </figure>
            </div>
            <nav>
                    <a href="./index.html" class="selected learn"><font><font>Learn </font></font></a> 
                    <a href="http://www.playframework.org/community" target="_blank" class="community"><font><font>Community </font></font></a> 
                    <a href="http://www.playframework.org/code" class="code"><font><font>Code </font></font></a> 
                    <a href="http://www.playframework.org/modules" target="_blank" class="modules"><font><font>모듈 </font></font></a> 
                    <a href="http://www.playframework.org/about" class="about"><font><font>About </font></font></a>
                    <a href="http://www.playframework.org/download" class="download"><font><font>Download</font></font></a> 
            </nav>
            <div id="download">
                
                    <p><font><font>
                        프로덕션 환경에 사용할 최신 패키지를 :
                    </font></font></p>
                    <a href="http://download.playframework.org/releases/play-2.0.3.zip" class="button"><font><font>play-2.0.3.zip</font></font></a>
                
                <p><font><font>또는 </font></font><a href="http://www.playframework.org/download"><font><font>모든 버전</font></font></a><font><font> 을 참조</font></font></p>
            </div>
        </header>
        <section id="top">
<div class="wrapper">
    <h1><a href="./index.html"><font><font>Manual, tutorials &amp; references</font></font></a></h1>
    <nav>
        <form method="get" action="http://www.google.com/search" id="search">
            <input type="search" placeholder="Search 2.0.3 on Google" name="q" results="10" size="29">
            <input type="hidden" name="sitesearch" value="playdocja.appspot.com/documentation/2.0.3"> 
            <input type="submit" style="position:absolute;top:-1000em">
        </form>
        <span class="versions">
            <span><font><font>Version 2.0.3</font></font></span>
            <select>
                <option disabled=""><font><font>Select version</font></font></option>
                                    <option selected="" value="#"><font><font>Version 2.0.3</font></font></option>
                                    <option value="#"><font><font>Version 2.0.2</font></font></option>
                                    <option value="#"><font><font>Version 2.0.1</font></font></option>
                                    <option value="#"><font><font>Version 2.0</font></font></option>
                                    <option value="#"><font><font>Version 1.2.5</font></font></option>
                                    <option value="#"><font><font>Version 1.2.4</font></font></option>
                                    <option value="#"><font><font>Version 1.2.3</font></font></option>
                                    <option value="#"><font><font>Version 1.2.2</font></font></option>
                                    <option value="#"><font><font>Version 1.2.1</font></font></option>
                                    <option value="#"><font><font>Version 1.2</font></font></option>
                                    <option value="#"><font><font>Version 1.1.1</font></font></option>
                                    <option value="#"><font><font>Version 1.1</font></font></option>
                                    <option value="#"><font><font>Version 1.0.3.2</font></font></option>
                                    <option value="#"><font><font>Version 1.0.2.1</font></font></option>
                                    <option value="#"><font><font>Version 1.0.1</font></font></option>
                                    <option value="#"><font><font>Version 1.0</font></font></option>
                            </select>
        </span>
        <span class="versions">
            <span><font><font>Browse APIs</font></font></span>
            <select>
                <option selected="" disabled=""><font><font>Select language</font></font></option>
                <option value="http://www.playframework.org/documentation/api/2.0.3/index.html"><font><font>Java API</font></font></option>
            </select>
        </span>
    </nav>
</div>
</section>
<script type="text/javascript" charset="utf-8" src="./javascripts/prettify.js"></script>
<script type="text/javascript">
$(function(){
    $("pre").addClass("prettyprint scala")
    window.prettyPrint && prettyPrint()
    $("select").change(function() {
        document.location = $(this).val()
    })
});
</script>
<style type="text/css">
@import "http://twitter.github.com/bootstrap/assets/js/google-code-prettify/prettify.css";
</style>

<div id="content" class="wrapper doc">
    <article>
        <h1><font><font>Play 2.0 소개</font></font></h1> 
<!--
Since 2007, we have been working on making Java web application development easier. Play started as an internal project at [[Zenexity|http://www.zenexity.com]] and was heavily influenced by our way of doing web projects: focusing on developer productivity, respecting web architecture, and using a fresh approach to packaging conventions from the start - breaking so-called JEE best practices where it made sense.
--> 
<p><font><font>2007 년 이후 우리는 Java에서 web 어플리케이션의 개발을 용이하게하려고했습니다. </font><font>Play는 </font></font><a href="http://www.zenexity.com/"><font><font>Zenexity</font></font></a><font><font> 의 내부 프로젝트로 시작하고 우리의 web 프로젝트 진행 방식에 강하게 영향을 받고 왔습니다. </font><font>즉, 개발자의 생산성에 초점을 맞추고, web 아키텍처를 존중하고 처음부터 패키징 약관에 참신한 방식을 채용하고 왔습니다 - 그렇게 할 말이 있다면, 이른바 JEE의 모범 사례도 깨고 왔습니다.</font></font></p> 
<!--
In 2009, we decided to share these ideas with the community as an open source project. The immediate feedback was extremely positive and the project gained a lot of traction. Today - after two years of active development - Play has several versions, an active community of 4,000 people, with a growing number of applications running in production all over the globe.
--> 
<p><font><font>2009 년, 우리는 이러한 아이디어를 오픈 소스 프로젝트로 커뮤니티와 공유 할 것을 결정했습니다. </font><font>즉시 반환 된 피드백은 매우 긍정적이며,이 프로젝트는 큰 관심을 끌고 있습니다. </font><font>오늘 - 2 년간의 활발한 개발을 거쳐 - Play에는 여러 버전이 있으며, 4,000 명의 참가자로 구성된 활발한 커뮤니티가 존재하고 전세계에서 실제로 사용되고있는 애플리케이션의 수는 계속 증가 있습니다.</font></font></p> 
<!--
Opening a project to the world certainly means more feedback, but it also means discovering and learning about new use cases, requiring features and un-earthing bugs that we were not specifically considered in the original design and its assumptions. During the two years of work on Play as an open source project we have worked to fix this kind of issues, as well as to integrate new features to support a wider range of scenarios. As the project has grown, we have learned a lot from our community and from our own experience - using Play in more and more complex and varied projects.
--> 
<p><font><font>전세계에 프로젝트를 해제하는 것은 물론 더 많은 피드백을 얻을 수 있다는 것이 있습니다 만, 그것은 또한 새로운 사례를 만나 거기에서 배울 수 있으며 새로운 기능이 필요할 하거나 원래의 설계 및 전제하에 고려되지 않던 버그가 밝혀 질 수도 있습니다. </font><font>오픈 소스 프로젝트로 Play에 임해 온 2 년 동안, 우리는 이러한 모든 문제를 해결하고, 또한 다양한 시나리오를 지원하기위한 새로운 기능을 통합했습니다. </font><font>Play 프로젝트가 성장함에 따라, 우리는 Play 사회와 우리 자신의 경험에서 배웠습니다 - Play는 점점 복잡하고 다양한 프로젝트에서 사용되게되어 왔습니다.</font></font></p> 
<!--
Meanwhile, technology and the web have continued to evolve. The web has become the central point of all applications. HTML, CSS and JavaScript technologies have evolved quickly - making it almost impossible for a server-side framework to keep up. The whole web architecture is fast moving towards real-time processing, and the emerging requirements of today’s project profiles mean SQL no longer works as the exclusive datastore technology. At the programming language level we’ve witnessed some monumental changes with several JVM languages, including Scala, gaining popularity.
--> 
<p><font><font>한편, 기술과 web의 진화의 행보는 멈출 줄 모릅니다. </font><font>web은 모든 응용 프로그램의 중심이되었습니다. </font><font>HTML, CSS, JavaScript의 기술은 급속히 발전하고 왔습니다 - 서버 측 프레임 워크가 따라가는 것은 거의 불가능할 정도입니다. </font><font>web 아키텍처는 총체적으로 실시간 처리 방향에 빠르게 가고 있으며 오늘의 프로젝트 그룹에 요구되게 된 사항에서 데이터 저장소 기술로 SQL을 유일한한다 순 없게 있는 것을 알 수 있습니다. </font><font>프로그래밍 언어 수준에서, 우리는 일반적으로되었다 Scala을 포함한 여러 JVM 언어에 관련된 후에까지 기억되도록 변화의 목격자가되었습니다.</font></font></p> 
<!--
That’s why we created Play 2.0, a new web framework for a new era.
--> 
<p><font><font>그것이야말로 새로운 시대의 web 프레임 워크, Play 2.0을 개발 한 이유입니다.</font></font></p> 
<!--
## Built for asynchronous programming
--> 
<h2><font><font>비동기 프로그래밍 구축</font></font></h2> 
<!--
Today’s web applications are integrating more concurrent real-time data, so web frameworks need to support a full asynchronous HTTP programming model. Play was initially designed to handle classic web applications with many short-lived requests. But now, the event model is the way to go for persistent connections - though Comet, long-polling and WebSockets.
--> 
<p><font><font>오늘의 web 어플리케이션은 어느 때보 다 실시간 데이터의 병렬 처리를 통합하게되어 왔으며, web 프레임 워크는 완전한 비동기 HTTP 프로그래밍 모델을 지원하는 것이 요구됩니다. </font><font>Play는 우선 단기간에 처리되는 대량의 요청을 처리하는 고전적인 web 응용 프로그램을 처리하도록 설계되었습니다. </font><font>그러나 오늘은 Comet 장기간 폴링 WebSockets 통해 연결을 유지 계속 연결을 처리하기 위해 이벤트 모델로 진행한다.</font></font></p> 
<!--
Play 2.0 is architected from the start under the assumption that every request is potentially long-lived. But that’s not all: we also need a powerful way to schedule and run long-running tasks. The Actor-based model is unquestionably the best model today to handle highly concurrent systems, and the best implementation of that model available for both Java and Scala is Akka - so it’s going in. Play 2.0 provides native Akka support for Play applications, making it possible to write highly-distributed systems.
--> 
<p><font><font>Play 2.0은 처음부터 모든 요청이 잠재적으로 장기간 유지되는 것으로 간주 설계되어 있습니다. </font><font>그러나뿐만 아니라, 우리는 장시간 처리되는 작업의 스케줄링과 실행을 취급 강력한 방법이 필요합니다. </font><font>오늘, 병렬도가 매우 높은 시스템을 취급하는 모델로는 Actor 기반 모델이 최선인지, 그리고 Java와 Scala 모두에서 사용할 수있는 Actor 기반 모델의 구현으로 Akka 최선의 것이다 것은 의문의 여지가 없습니다 - 이것이 Akka를 사용하는 이유입니다. </font><font>Play 2.0 Play 응용 프로그램 Akka를 기본적으로 지원하고 고급 분산 시스템을 쓸 수 있도록합니다.</font></font></p> 
<!--
## Focused on type safety
--> 
<h2><font><font>형 안전에 초점</font></font></h2> 
<!--
One benefit of using a statically-typed programming language for writing Play applications is that the compiler can check parts of your code. This is not only useful for detecting mistakes early in the development process, but it also makes it a lot easier to work on large projects with a lot developers involved.
--> 
<p><font><font>Play 응용 프로그램을 작성하기위한 언어로 정적 타입 언어를 사용하는 이점 중 하나는 컴파일러가 코드의 어떤 부분을 체크 할 수 있다는 점에 있습니다. </font><font>이것은 개발 과정 초기에 오류를 감지하는 데 효과적 일뿐 아니라, 많은 개발자가 참여하는 대규모 프로젝트에서의 작업을 매우 용이하게 해줍니다.</font></font></p> 
<!--
Adding Scala to the mix for Play 2.0, we clearly benefit from even stronger compiler guarantees - but that’s not enough. In Play 1.x, the template system was dynamic, based on the Groovy language, and the compiler couldn’t do much for you. As a result, errors in templates could only be detected at run-time. The same goes for verification of glue code with controllers.
--> 
<p><font><font>Play 2.0에서 Scala를 추가함으로써 우리는 확실히 컴파일러 더욱 강력한 보장이라는 이점을 얻을 수 있습니다 -하지만 아직도 충분하지 않습니다. </font><font>Play 1.x는 템플릿 시스템은 동적이며, Groovy를 기반으로, 컴파일러에있는 것은 그다지 없었습니다. </font><font>그 결과, 템플릿에서 발생하는 오류는 런타임에만 발견 할 수 없었습니다. </font><font>이것은 컨트롤러 사이를 주선 코드 검증에 대해서도 마찬가지했습니다.</font></font></p> 
<!--
In version 2.0, we really wanted to push this idea of having Play check most of your code at compilation time further. This is why we decided to use the Scala-based template engine as the default for Play applications - even for developers using Java as the main programming language. This doesn’t mean that you have to become a Scala expert to write templates in Play 2.0, just as you were not really required to know Groovy to write templates in Play 1.x.
--> 
<p><font><font>우리는 Play 2.0에서 대부분의 코드를 컴파일시에 체크 시킨다는 생각을 더욱 추진하고 싶다고 강하게 생각하고 있습니다. </font><font>따라서 우리는 Play 응용 프로그램의 기본으로, Scala 기반 템플릿 엔진을 사용하기로 결정했습니다 - 그것은 Java를 기본 프로그래밍 언어로 사용하는 개발자에게도입니다. </font><font>그러나 그렇다고 Play 1.x에서 템플릿을 작성, Groovy를 정말 알고 있어야이었다 것은 아니다 것처럼, Scala 전문가가되어야 Play 2.0 템플릿을 쓸 수 없다는 는 없습니다.</font></font></p> 
<!--
In templates, Scala is mainly used to navigate your object graph in order to display relevant information, with a syntax that is very close to Java’s. However, if you want to unleash the power of Scala to write advanced templates abstractions, you will quickly discover how Scala, being expression-oriented and functional, is a perfect fit for a template engine.
--> 
<p><font><font>Scala가 주로 사용되는 것은, Java의 구문에 매우 가까운 구문을 사용하여 필요한 정보를 표시하는 개체 그래프를 더듬어가는 것입니다. </font><font>그렇다고는해도, Scala가 가지는 파워를 살려 고도로 추상화 된 템플릿을 쓰고 싶다면 식 지향 함수형이다 Scala이 얼마나 템플릿 엔진에 딱인지는 곧바로 이해할 수있을 것입니다.</font></font></p> 
<!--
And that’s not only true for the template engine: the routing system is also fully type-checked. Play 2.0 checks your routes’ descriptions, and verifies that everything is consistent, including the reverse routing part.
--> 
<p><font><font>그리고 이것은 템플릿 엔진 만 말할 수는 없습니다. </font><font>라우팅 시스템도 완전히 형이 검사되는 것입니다. </font><font>Play 2.0은 루트에 대한 언급을 확인하고 역 루트 부분을 포함하여 모두에서 일관성이 유지되고 있는지를 확인합니다.</font></font></p> 
<!--
A nice side effect of being fully compiled is that the templates and route files will be easier to package and reuse. You also get a significant performance gain on these parts at run-time.
--> 
<p><font><font>완전히 컴파일을 수있는 즐거운 부작용으로 템플릿과 루트 파일 패키징 및 재사용이 용이하게 될 것으로이 부분의 런타임 성능의 대폭적인 향상을 전망하는 것도 있습니다.</font></font></p> 
<!--
## Native support for Java and Scala
--> 
<h2><font><font>Java 및 Scala의 네이티브 지원</font></font></h2> 
<!--
Early in the Play project’s history, we started exploring the possibility of using the Scala programming language for writing Play applications. We initially introduced this work as an external module, to be able to experiment freely without impacting the framework itself.
--> 
<p><font><font>Play 1.1에서 Play 응용 프로그램을 작성하는 프로그래밍 언어 Scala를 사용하는 가능성을 우리가 모색하기 시작했습니다. </font><font>이 작업은 먼저 프레임 워크 자체에 영향을주지 않고 자유롭게 시험 할 수있는 외부 모듈로 도입되었습니다.</font></font></p> 
<!--
Properly integrating Scala into a Java-based framework is not trivial. Considering Scala’s compatibility with Java, one can quickly achieve a first naive integration that simply uses Scala’s syntax instead of Java’s. This, however, is certainly not the optimal way of using the language. Scala is a mix of true object orientation with functional programming. Leveraging the full power of Scala requires rethinking most of the framework’s APIs.
--> 
<p><font><font>Scala를 적절히 Java 기반의 프레임 워크에 통합하는 것은 쉬운 일이 아닙니다. </font><font>Scala가 가진 Java와의 호환성을 고려하면 단순히 Scala의 구문을 Java의 구문 대신 사용 형태로 먼저 단순히 빠르게 통합 해 버리는 것은 가능합니다. </font><font>그러나 이것은 확실히 Scala를 이용하는데있어서 가장 좋은 방법은 없습니다. </font><font>Scala는 진정한 객체 지향과 함수 프로그래밍을 혼합 한 것입니다. </font><font>Scala의 진정한 파워를 해제하려면 Play 프레임 워크의 API를 많이 검토해야합니다.</font></font></p> 
<!--
We quickly reached the limits of what we can do with Scala support as a separate module. Initial design choices we made in Play 1.x, relying heavily on Java reflection API and byte code manipulation, have made it harder to progress without completely rethinking some essential parts of Play’s internals. Meanwhile, we have created several awesome components for the Scala module, such as the new type-safe template engine and the brand new SQL access component Anorm. This is why we decided that, to fully unleash the power of Scala with Play, we would move Scala support from a separate module to the core of Play 2.0, which is designed from the beginning to natively support Scala as a programming language.
--> 
<p><font><font>지금 우리는 별도의 모듈로 Scala를 지원하는 방식의 한계점에 도달하고 있습니다. </font><font>우리가 Play 1.x에서 실시한 초기 설계의 선택은 Java 리플렉션 API와 바이트 코드 조작에 크게 의존하고있어, Play 내부의 중요한 부분의 일부에 대해 완전히 재검토 고치지 않으면, 더 이상 발전은 어려워지고있었습니다. </font><font>한편, 우리는 Scala 모듈을 위해 새로운 형식 안전 템플릿 엔진과 완전히 새로운 SQL 액세스 구성 요소 인 Anorm 등 여러 좋은 구성 요소를 만들고있었습니다. </font><font>그래서 우리는 Scala가 가지는 파워를 Play에서 완전히 해방하기 위해 Scala 지원을 개별 모듈에서 Play 2.0 코어로 옮기는 ​​것을 결정했습니다. </font><font>이 Play 2.0의 핵심은 처음부터 프로그래밍 언어로 Scala를 기본적으로 지원하도록 설계된 것입니다.</font></font></p> 
<!--
Java, on the other hand, is certainly not getting any less support from Play 2.0; quite the contrary. The Play 2.0 build provides us with an opportunity to enhance the development experience for Java developers. Java developers get a real Java API written with all the Java specificity in mind.
--> 
<p><font><font>한편, Java 지원이 Play 2.0에서 약 해지는 것은 전혀 없습니다. </font><font>오히려 완전히 그 반대입니다. </font><font>Play 2.0 빌드는 Java 개발자에게 개발의 경험을 확장하는 기회를 제공합니다.</font></font></p> 
<!--
## Powerful build system
--> 
<h2><font><font>강력한 빌드 시스템</font></font></h2> 
<!--
From the beginning of the Play project, we have chosen a fresh way to run, compile and deploy Play applications. It may have looked like an esoteric design at first, but it was crucial to providing an asynchronous HTTP API instead of the standard Servlet API, short feedback cycles through live compilation and reloading of source code during development, and promoting a fresh packaging approach. Consequently, it was difficult to make Play follow the standard JEE conventions.
--> 
<p><font><font>우리는 처음부터 Play 응용 프로그램의 실행, 컴파일, 배포에 대한 새로운 방법을 선택했습니다. </font><font>당초 우리가 취한 방법은 난해한 디자인 보였을지도 모릅니다 -하지만 표준 Servlet API 대신 비동기 HTTP API를 제공하고 라이브 컴파일 개발중인 소스 코드를 다시로드하여 짧은 피드백 사이클을 제공하고 참신한 패키징 방식을 추진하는 것은 매우 중요한 일이었습니다. </font><font>그 결과로, Play가 표준 JEE의 약관을 준수하는 것은 어렵습니다.</font></font></p> 
<!--
Today, this idea of container-less deployment is increasingly accepted in the Java world. It’s a design choice that has allowed the Play framework to run natively on platforms like Heroku, which introduced a model that we consider the future of Java application deployment on elastic PaaS platforms.
--> 
<p><font><font>오늘은 컨테이너리스 배포의 개념은 Java 세계에서 매우 널리 받아 들여지게되어 왔습니다. </font><font>이 디자인 선택은 Play framework는 Heroku 같은 플랫폼에서 네이티브하게 동작 할 수 있습니다. </font><font>우리는 Heroku에 의해 소개 된 모델은 탄성 인 PaaS 플랫폼의 Java 응용 프로그램 배포의 미래라고 생각합니다.</font></font></p> 
<!--
Existing Java build systems, however, were not flexible enough to support this new approach. Since we wanted to provide straightforward tools to run and deploy Play applications, in Play 1.x we created a collection of Python scripts to handle build and deployment tasks.
--> 
<p><font><font>한편, 기존의 Java 빌드 시스템이 새로운 접근 방식을 지원하려면 유연성이 부족했습니다. </font><font>우리는 Play 응용 프로그램을 실행하고 배포하기위한 단순 명쾌한 도구를 제공하고 싶다고 생각하고 있던 것으로부터, Play 1.x에서는 빌드 및 배포 작업을 모두 처리하기 위해 Python 스크립트 집합체를 만들어 냈습니다.</font></font></p> 
<!--
Meanwhile, developers using Play for more enterprise-scale projects, which require build process customization and integration with their existing company build systems, were a bit lost. The Python scripts we provide with Play 1.x are in no way a fully-featured build system and are not easily customizable. That’s why we’ve decided to go for a more powerful build system for Play 2.0.
--> 
<p><font><font>그러나 빌드 프로세스의 정의, 기업의 기존 빌드 시스템과의 통합이 요구되는보다 엔터프라이즈 프로젝트에서 Play를 사용하는 개발자 분들은 조금 곤란했습니다. </font><font>우리가 Play 1.x에서 제공 한 Python 스크립트 군은 완전한 기능을 갖춘 빌드 시스템은 전혀 없었으며, 정의도 쉽지 않았습니다. </font><font>이것이 우리가 Play 2.0 더 강력한 빌드 시스템에 방향타를 자르는 것을 결정한 이유입니다.</font></font></p> 
<!--
Since we need a modern build tool, flexible enough to support Play original conventions and able to build Java and Scala projects, we have chosen to integrate sbt in Play 2.0. This, however, should not scare existing Play users who are happy with the simplicity of the original Play build. We are leveraging the same simple `play new`, `run`, `start` experience on top of an extensible model: Play 2.0 comes with a preconfigured build script that will just work for most users. On the other hand, if you need to change the way your application is built and deployed, the fact that a Play project is a standard sbt project gives you all the power you need to customize and adapt it.
--> 
<p><font><font>Play 자체 규약을 지원하며, Java와 Scala 프로젝트를 빌드 할 수있는 충분한 유연성을 가진 현대적인 빌드 도구가 필요했던 점에서 우리는 SBT을 Play 2.0에 통합하기로했습니다. </font><font>그러나 이는 기존의 Play 빌드 단순 만족 한 사용자가 위협받을 수 있어서는 안됩니다. </font><font>우리는 확장 성있는 모델에, 지금까지와 같이 간단한 </font></font><code><font><font>play new</font></font></code><font><font> , </font></font><code><font><font>run</font></font></code><font><font> , </font></font><code><font><font>start</font></font></code><font><font> 가 체험 할 수 있도록 노력하고 있습니다. </font><font>Play 2.0은 대부분의 사용자에게는 어쨌든 단순히 잘 처리를 해내주는 구성된 빌드 스크립트를 가지게됩니다. </font><font>한편, 응용 프로그램 빌드 및 배포 방법을 변경해야 할 경우, Play 프로젝트는 표준 SBT 프로젝트되므로, 사용자 나 특별한 요구에 적용를 충족시킬뿐만의 모든 파워를 활용할 수있는 입니다.</font></font></p> 
<!--
This also means better integration with Maven projects out of the box, the ability to package and publish your project as a simple set of JAR files to any repository, and especially live compiling and reloading at development time of any depended project, even for standard Java or Scala library projects.
--> 
<p><font><font>이것은 또한 Play 2.0은 설치 직후부터 Maven 통합이 지금까지보다 잘 할 수 있다는 것이기도 프로젝트를 간단한 jar 파일의 집합체로 패키징하여 모든 저장소에 공개 할 수 있다는 그렇지만이 더 의존하고있는 모든 표준 Java 또는 Scala 라이브러리가 개발중인 상태에도 라이브 컴파일 및 재 로딩이 가능하다는 것도 있습니다.</font></font></p> 
<!--
## Datastore and model integration
--> 
<h2><font><font>데이터 저장소와 모델의 통합</font></font></h2> 
<!--
‘Data store’ is no longer synonymous with ‘SQL database’, and probably never was. A lot of interesting data storage models are becoming popular, providing different properties for different scenarios. For this reason it has become difficult for a web framework like Play to make bold assumptions regarding the kind of data store that developers will use. A generic model concept in Play no longer makes sense, since it is almost impossible to abstract over all these kinds of technologies with a single API.
--> 
<p><font><font>데이터 저장소는 더 이상 "SQL 데이터베이스"의 동의어는 아니며, 아마도 지금까지 그렇게하지 ​​못했습니다. </font><font>데이터 저장소의 흥미로운 모델은 많은 것이 널리 사용되게 다양한 시나리오에서 다양한 특징을 제공했습니다. </font><font>따라서 Play 같은 web 프레임 워크에게는 개발자가 어떤 데이터 저장소를 이용하는지 명확한 추측하기 어렵게되어 왔습니다. </font><font>Play의 일반 모델의 개념은 단일 API에서 이러한 기술 모두를 추상화하는 것은 거의 불가능하다 이상 더 이상 이해되지 않는 것이되어 버렸습니다.</font></font></p> 
<!--
In Play 2.0, we wanted to make it really easy to use any data store driver, ORM, or any other database access library without any special integration with the web framework. We simply want to offer a minimal set of helpers to handle common technical issues, like managing the connection bounds. We also want, however, to maintain the full-stack aspect of Play framework by bundling default tools to access classical databases for users WHO don’t have specialized needs, and that’s why Play 2.0 comes with built-in relational database access libraries such as Ebean, JPA and Anorm.
--> 
<p><font><font>우리는 Play 2.0에서 어떤 데이터 저장소 드라이버, ORM 또는 다른 데이터베이스 액세스 라이브러리, 특히이 프레임 워크에 통합하지 않고 쉽게 이용할 수 있도록하고 싶다고 생각하고 있습니다. </font><font>우리는 단순히 연결 바인딩의 관리와 같은 일반적인 기술적 과제를 처리하기위한 최소한의 도우미를 제공하도록하고 싶습니다. </font><font>그렇다고는해도, 우리는 또한 특별한 요구가없는 사용자가 고전적인 데이터베이스에 액세스하기위한 기본 도구를 번들함으로써 Play 프레임 워크의 전체 스택이라는 성격도 간직하고 생각합니다 . </font><font>그것이야말로 Play 2.0 Ebean, JPA, Anorm 등 빌트인의 관계형 데이터베이스 액세스 라이브러리를 포함하고있는 이유입니다.</font></font></p>
    </article>
    <aside>
    <h3><font><font>공식 문서</font></font></h3>
        <p>
            <a href="http://www.playframework.org/documentation/2.0.3/Philosophy" target="_blank"><font><font>Documentation : Philosophy - Playframework</font></font></a>
        </p>
 <ul> 
 <li><a href="./installing.html"><font><font>Play 2.0 설치</font></font></a></li> 
 <li><a href="./newapplication.html"><font><font>새 응용 프로그램을 만들</font></font></a></li> 
 <li><a href="./anatomy.html"><font><font>Play 2.0 응용 프로그램의 구조</font></font></a></li> 
 <li><a href="./playconsole.html"><font><font>Play 2.0 콘솔을 사용</font></font></a></li> 
 <li><a href="./ide.html"><font><font>좋아하는 IDE에서 개발하는</font></font></a></li> 
 <li><a href="./samples.html"><font><font>샘플 응용 프로그램</font></font></a></li> 
</ul> 
<!--
### Working with Play 2.0
-->
<h3><font><font>Play 2.0 개발</font></font></h3> 
<!--
- [[Play 2.0 for Scala developers | ScalaHome]]
- [[Play 2.0 for Java developers | JavaHome]]
--> 
<ul> 
 <li><a href="./scaladocs/scalahome.html"><font><font>Scala 개발자를위한 Play 2.0</font></font></a></li> 
 <li><a href="./javadocs/javahome.html"><font><font>Java 개발자를위한 Play 2.0</font></font></a></li> 
</ul> 
<!--
### Detailed topics
-->
<h3><font><font>자세한 주제</font></font></h3> 
<!--
- [[The Build system | Build]]
- [[Working with public assets | Assets]]
- [[Managing database evolutions | Evolutions]]
- [[Configuration file syntax and features | Configuration]]
- [[Deploying your application | Production]]
--> 
<ul> 
 <li><a href="./build/build.html"><font><font>빌드 시스템</font></font></a></li> 
 <li><a href="./assets/assets.html"><font><font>공개 에셋을 사용</font></font></a></li> 
 <li><a href="./evolutions/evolutions.html"><font><font>Evolutions에서 데이터베이스 관리</font></font></a></li> 
 <li><a href="./configuration/configuration.html"><font><font>설정 파일의 구문과 기능</font></font></a></li> 
 <li><a href="./production/production.html"><font><font>응용 프로그램 배포</font></font></a></li> 
</ul> 
<!--
### Additional documentation
-->
<h3><font><font>기타 문서</font></font></h3> 
<ul> 
 <li><a href="http://docs.scala-lang.org/"><font><font>Scala</font></font></a></li> 
 <li><a href="http://akka.io/docs/"><font><font>Akka</font></font></a></li> 
 <li><a href="http://www.scala-sbt.org/learn.html"><font><font>sbt</font></font></a></li> 
 <li><a href="https://github.com/typesafehub/config"><font><font>Configuration</font></font></a></li> 
 <li><a href="http://logback.qos.ch/documentation.html"><font><font>Logback</font></font></a></li> 
</ul>
                        <h3><font><font>도서</font></font></h3>
                        <p><a title="Play for Scala" href="http://bit.ly/playscala"><img src="./images/play-for-scala-cover.jpg"></a></p>
        <p><a title="Play for Java" href="http://bit.ly/playjava"><img src="./images/play-for-java-cover.jpg"></a></p>
               
    </aside>
</div>
        <footer>
            <img class="logo" src="./images/logo-footer.png">
            <div class="links">
                <dl>
                    <dt><font><font>Play</font></font></dt>
                    <dd><a href="http://www.playframework.org/download"><font><font>Downloads</font></font></a></dd>
                    <dd><a href="http://www.playframework.org/documentation/latest"><font><font>Documentation</font></font></a></dd>
                    <dd><a href="http://www.apache.org/licenses/LICENSE-2.0.html"><font><font>License</font></font></a></dd>
                </dl>
                <dl>
                    <dt><font><font>Contribute</font></font></dt>
                    <dd><a href="http://github.com/playframework/Play20"><font><font>Source code</font></font></a></dd>
                    <dd><a href="https://groups.google.com/forum/#!forum/play-framework"><font><font>Mailling list</font></font></a></dd>
                    <dd><a href="https://play.lighthouseapp.com/dashboard"><font><font>Bug tracker</font></font></a></dd>
                </dl>
                <dl>
                    <dt><font><font>Ecosystem</font></font></dt>
                    <dd><a href="http://www.playframework.org/code/team" target="_blank"><font><font>Team &amp; contributors</font></font></a></dd>
                    <dd><a href="http://typesafe.com/stack"><font><font>Commercial support</font></font></a></dd>
                    <dd><a href="http://www.playframework.org/modules" target="_blank"><font><font>Modules</font></font></a></dd>
                </dl>
            </div>
            <div class="licence"><font><font>
                play Framework is Released 신청 the </font></font><a href="http://www.apache.org/licenses/LICENSE-2.0.html"><font><font>아파치 2 License</font></font></a>
                <a class="typesafe" href="http://typesafe.com/"><img src="./images/typesafe.png"></a>
                <a class="zenexity" href="http://zenexity.com/"><img src="./images/zenexity.png"></a>
            </div>
        </footer>
</body></html>