<!DOCTYPE html>
<!-- saved from url=(0053)http://playdocja.appspot.com/documentation/2.0.3/Home -->
<html class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Documentation : Home - Playframework</title>
        <link rel="stylesheet" media="screen" href="../stylesheets/main.css">
        <link rel="shortcut icon" type="image/png" href="../images/favicon.png">
                <meta name="viewport" content="width=1024, initial-scale=1">
        <script src="../javascripts/jquery-1.7.1.min.js" type="text/javascript"></script>
        <script src="../javascripts/play20.js" type="text/javascript"></script>
                <script src="../javascripts/urchin.js" type="text/javascript"></script> 
        <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script src="../javascripts/ga.js" type="text/javascript"></script>
        <script type="text/javascript">
            try {
                var pageTracker = _gat._getTracker("UA-13089827-4");
                pageTracker._trackPageview();
            } catch(err) {}
        </script>
    <link type="text/css" rel="stylesheet" charset="UTF-8" href="../stylesheets/translateelement.css"><script type="text/javascript" charset="UTF-8" src="../javascripts/main_ko.js"></script><script type="text/javascript" charset="UTF-8" src="../javascripts/element_main.js"></script></head>
    <body>
        <header>
            <a href="../index.html" id="logo"><img src="../images/playframework.png"></a>
            <div id="getLogo">
                <h3><font><font>Play! 로고 다운로드</font></font></h3>
                <figure>
                    <img src="../images/normal-mini.png">
                     <figcaption>
                        <a href="../images/logos/normal.png"><font><font>(png) </font></font></a>
                        <a href="../images/logos/normal.svg"><font><font>(svg)</font></font></a>
                     </figcaption>
                </figure>
                <figure>
                    <img src="../images/black-mini.png">
                     <figcaption>
                        <a href="../images/logos/black.png"><font><font>(png) </font></font></a>
                        <a href="../images/logos/black.svg"><font><font>(svg)</font></font></a>
                     </figcaption>
                </figure>
            </div>
            <nav>
                    <a href="../index.html" class="selected learn"><font><font>Learn </font></font></a> 
                    <a href="http://www.playframework.org/community" target="_blank" class="community"><font><font>Community </font></font></a> 
                    <a href="http://www.playframework.org/code" class="code"><font><font>Code </font></font></a> 
                    <a href="http://www.playframework.org/modules" target="_blank" class="modules"><font><font>모듈 </font></font></a> 
                    <a href="http://www.playframework.org/about" class="about"><font><font>About </font></font></a>
                    <a href="http://www.playframework.org/download" class="download"><font><font>Download</font></font></a> 
            </nav>
            <div id="download">
                
                    <p><font><font>
                        프로덕션 환경에 사용할 최신 패키지를 :
                    </font></font></p>
                    <a href="http://download.playframework.org/releases/play-2.0.3.zip" class="button"><font><font>play-2.0.3.zip</font></font></a>
                
                <p><font><font>또는 </font></font><a href="http://www.playframework.org/download"><font><font>모든 버전</font></font></a><font><font> 을 참조</font></font></p>
            </div>
        </header>
        <section id="top">
<div class="wrapper">
    <h1><a href="../index.html"><font><font>Manual, tutorials &amp; references</font></font></a></h1>
    <nav>
        <form method="get" action="http://www.google.com/search" id="search">
            <input type="search" placeholder="Search 2.0.3 on Google" name="q" results="10" size="29">
            <input type="hidden" name="sitesearch" value="playdocja.appspot.com/documentation/2.0.3"> 
            <input type="submit" style="position:absolute;top:-1000em">
        </form>
        <span class="versions">
            <span><font><font>Version 2.0.3</font></font></span>
            <select>
                <option disabled=""><font><font>Select version</font></font></option>
                                    <option selected="" value="#"><font><font>Version 2.0.3</font></font></option>
                                    <option value="#"><font><font>Version 2.0.2</font></font></option>
                                    <option value="#"><font><font>Version 2.0.1</font></font></option>
                                    <option value="#"><font><font>Version 2.0</font></font></option>
                                    <option value="#"><font><font>Version 1.2.5</font></font></option>
                                    <option value="#"><font><font>Version 1.2.4</font></font></option>
                                    <option value="#"><font><font>Version 1.2.3</font></font></option>
                                    <option value="#"><font><font>Version 1.2.2</font></font></option>
                                    <option value="#"><font><font>Version 1.2.1</font></font></option>
                                    <option value="#"><font><font>Version 1.2</font></font></option>
                                    <option value="#"><font><font>Version 1.1.1</font></font></option>
                                    <option value="#"><font><font>Version 1.1</font></font></option>
                                    <option value="#"><font><font>Version 1.0.3.2</font></font></option>
                                    <option value="#"><font><font>Version 1.0.2.1</font></font></option>
                                    <option value="#"><font><font>Version 1.0.1</font></font></option>
                                    <option value="#"><font><font>Version 1.0</font></font></option>
                            </select>
        </span>
        <span class="versions">
            <span><font><font>Browse APIs</font></font></span>
            <select>
                <option selected="" disabled=""><font><font>Select language</font></font></option>
                <option value="http://www.playframework.org/documentation/api/2.0.3/index.html"><font><font>Java API</font></font></option>
            </select>
        </span>
    </nav>
</div>
</section>
<script type="text/javascript" charset="utf-8" src="../javascripts/prettify.js"></script>
<script type="text/javascript">
$(function(){
    $("pre").addClass("prettyprint scala")
    window.prettyPrint && prettyPrint()
    $("select").change(function() {
        document.location = $(this).val()
    })
});
</script>
<style type="text/css">
@import "http://twitter.github.com/bootstrap/assets/js/google-code-prettify/prettify.css";
</style>

<div id="content" class="wrapper doc">
    <article>
        <h1><font><font>설정 파일의 구문과 기능</font></font></h1> 
<!--
> The configuration file used by Play is based on the [[Typesafe config library | https://github.com/typesafehub/config]].
--> 
<blockquote> 
 <p><font><font>Play의 설정 파일은 </font></font><a href="https://github.com/typesafehub/config"><font><font>Typesafe config library</font></font></a><font><font>　를 기반으로하고 있습니다.</font></font></p> 
</blockquote> 
<!--
The default configuration file of a Play 2.0 application must be defined in `conf/application.conf`. It uses the HOCON format ( "Human-Optimized Config Object Notation").
--> 
<p><font><font>Play 2.0 응용 프로그램의 기본 설정 파일은 </font></font><code><font><font>conf / application.conf</font></font></code><font><font> 에 저장되어 있어야합니다. </font><font>또한,이 설정 파일은 HOCON 형식 ( "Human-Optimized Config Object Notation")로 기술되어 있습니다.</font></font></p> 
<!--
## Specifying an alternative configuration file
--> 
<h2><font><font>대체 설정 파일 지정</font></font></h2> 
<!--
System properties can be used to force a different config source:
--> 
<p><font><font>시스템 속성을 사용하면 다른 설정 소스의 사용을 강제 할 수 있습니다.</font></font></p> 
<!--
* `config.resource` specifies a resource name - not a basename, i.e. application and not application.conf
* `config.file` specifies a filesystem path, again it should include the extension, not be a basename
* `config.url` specifies a URL
--> 
<ul> 
 <li><code><font><font>config.resource</font></font></code><font><font> 는 리소스 파일의 지정입니다 - application 같은 기반 이름 지정은 할 수 없습니다. </font><font>또한 application.conf 이외를 지정합니다.</font></font></li> 
 <li><code><font><font>config.file</font></font></code><font><font> 는 파일 시스템의 경로를 지정합니다. </font><font>경로에 확장자를 포함합니다. </font><font>기반 이름 지정은 할 수 없습니다.</font></font></li> 
 <li><code><font><font>config.url</font></font></code><font><font> 는 URL의 지정입니다.</font></font></li> 
</ul> 
<!--
These system properties specify a replacement for `application.conf`, not an addition. In the replacement config file, you can use include "application" to include the original default config file; after the include statement you could go on to override certain settings.
--> 
<p><font><font>이러한 시스템 속성은 </font></font><code><font><font>application.conf</font></font></code><font><font> 의 대체가되는 설정 파일의 지정에 사용합니다. </font><font>될 대안이며, 추가가 아님에 유의하십시오. </font><font>그러나 될 대안이되는 설정 파일에 include "application"라고 기술하여 기본 설정 파일을 include 할 수 있습니다. </font><font>또한 include 문 후에 모든 설정을 덮어 쓸 수 있습니다.</font></font></p> 
<!--
## Using with Akka
--> 
<h2><font><font>Akka와 함께 사용</font></font></h2> 
<!--
Akka 2.0 will use the same configuration file as the one defined for your Play 2.0 application. Meaning that you can configure anything in Akka in the `application.conf` directory.
--> 
<p><font><font>Akka 2.0 Play 2.0 응용 프로그램과 같은 설정 파일을 읽습니다. </font><font>즉, Akka 관한 모든 설정은 </font></font><code><font><font>application.conf</font></font></code><font><font> 에서 할 수 있습니다.</font></font></p> 
<!--
## HOCON Syntax
--> 
<h2><font><font>HOCON 문법</font></font></h2> 
<!--
Much of this is defined with reference to JSON; you can find the JSON spec at http://json.org/ of course.
--> 
<p><font><font>HOCON의 문법은 거의 JSON 따라 정의되어 있습니다. </font><font>JSON 사양은 </font></font><a href="http://json.org/"><font><font>http://json.org/</font></font></a><font><font> 있습니다.</font></font></p> 
<!--
### Unchanged from JSON
--> 
<h3><font><font>JSON과 같은 부분</font></font></h3> 
<!--
 - files must be valid UTF-8
 - quoted strings are in the same format as JSON strings
 - values have possible types: string, number, object, array, boolean, null
 - allowed number formats matches JSON; as in JSON, some possible
   floating-point values are not represented, such as `NaN`
--> 
<ul> 
 <li><font><font>파일은 UTF-8 형식이어야한다</font></font></li> 
 <li><font><font>인용 된 문자열은 JSON 문자열과 같은 형식이다</font></font></li> 
 <li><font><font>사용 가능한 형식은 string, number, object, array, boolean, null</font></font></li> 
 <li><font><font>JSON과 같은 숫자 형식을 사용할 수 있습니다. </font><font>JSON 아니라 </font></font><code><font><font>NaN</font></font></code><font><font> 처럼 표현 불가능한 부동 소수점 수가있다.</font></font></li> 
</ul> 
<!--
### Comments
--> 
<h3><font><font>코멘트</font></font></h3> 
<!--
Anything between `//` or `#` and the next newline is considered a comment and ignored, unless the `//` or `#` is inside a quoted string.
--> 
<p><code><font><font>/ /</font></font></code><font><font> 나 </font></font><code><font><font>#</font></font></code><font><font> 에서 다음 줄까지 주석으로 무시됩니다. </font><font>그러나 </font></font><code><font><font>/ /</font></font></code><font><font> 나 </font></font><code><font><font>#</font></font></code><font><font> 이 인용 문자열 안에있는 경우는 포함되지 않습니다.</font></font></p> 
<!--
### Omit root braces
--> 
<h3><font><font>root의 괄호 생략</font></font></h3> 
<!--
JSON documents must have an array or object at the root. Empty files are invalid documents, as are files containing only a non-array non-object value such as a string.
--> 
<p><font><font>JSON 문서는 root로 array 나 object를 하나 가지고 있어야합니다. </font><font>빈 파일이거나, 또는 string 등의 array 나 object 이외 밖에 포함되지 않은 파일은 JSON 문서로 올바르지 않습니다.</font></font></p> 
<!--
In HOCON, if the file does not begin with a square bracket or curly brace, it is parsed as if it were enclosed with `{}` curly braces.
--> 
<p><font><font>HOCON는 파일이 중괄호와 대괄호로 시작하지 않는 경우 중괄호 </font></font><code><font><font>{}</font></font></code><font><font> 로 묶여있는 것으로 파싱합니다.</font></font></p> 
<!--
A HOCON file is invalid if it omits the opening `{` but still has a closing `}`; the curly braces must be balanced.
--> 
<p><font><font>하지만 시작 중괄호 </font></font><code><font><font>{</font></font></code><font><font> 이 있음에도 불구하고 닫 중괄호 </font></font><code><font><font>}</font></font></code><font><font> 가 존재하지 않는 것 같은 파일 HOCON 형식으로 올바르지 않습니다. </font><font>괄호는 균형 된해야합니다.</font></font></p> 
<!--
### Key-value separator
--> 
<h3><font><font>Key-value의 구분</font></font></h3> 
<!--
The `=` character can be used anywhere JSON allows `:`, i.e. to separate keys from values.
--> 
<p><font><font>JSON에서 키와 값을 구분하는 데 </font></font><code><font><font>:</font></font></code><font><font> 이 기대되는 같은 곳은 </font></font><code><font><font>=</font></font></code><font><font> 을 사용할 수 있습니다.</font></font></p> 
<!--
If a key is followed by `{`, the `:` or `=` may be omitted. So `"foo" {}` means `"foo" : {}"`
--> 
<p><font><font>키 직후 </font></font><code><font><font>{</font></font></code><font><font> 이 나타난 경우 </font></font><code><font><font>:</font></font></code><font><font> 나 </font></font><code><font><font>=</font></font></code><font><font> 는 선택 사항입니다. </font><font>즉, </font></font><code><font><font>"foo"{}</font></font></code><font><font> 는 </font></font><code><font><font>"foo": {}</font></font></code><font><font> 와 같은 의미입니다.</font></font></p> 
<!--
### Commas
--> 
<h3><font><font>쉼표</font></font></h3> 
<!--
Values in arrays, and fields in objects, need not have a comma between them as long as they have at least one ASCII newline (`\n`, decimal value 10) between them.
--> 
<p><font><font>배열의 값이나 개체의 필드를 구분하는 쉼표는 하나 이상의 줄 바꿈 ( </font></font><code><font><font>\ n</font></font></code><font><font> , 10 진수 ASCII 코드로 말하면 10)가 있으면 선택 사항입니다.</font></font></p> 
<!--
The last element in an array or last field in an object may be followed by a single comma. This extra comma is ignored.
--> 
<p><font><font>배열의 마지막 요소 나 개체의 마지막 필드 다음에 하나만 쉼표를 작성할 수 있습니다. </font><font>이 여분의 쉼표는 무시됩니다.</font></font></p> 
<!--
 - `[1,2,3,]` and `[1,2,3]` are the same array.
 - `[1\n2\n3]` and `[1,2,3]` are the same array.
 - `[1,2,3,,]` is invalid because it has two trailing commas.
 - `[,1,2,3]` is invalid because it has an initial comma.
 - `[1,,2,3]` is invalid because it has two commas in a row.
 - these same comma rules apply to fields in objects.
--> 
<ul> 
 <li><code><font><font>[1,2,3,]</font></font></code><font><font> 와 </font></font><code><font><font>[1,2,3]</font></font></code><font><font> 은 같은 배열입니다.</font></font></li> 
 <li><code><font><font>[1 \ n2 \ n3]</font></font></code><font><font> 와 </font></font><code><font><font>[1,2,3]</font></font></code><font><font> 은 같은 배열입니다.</font></font></li> 
 <li><code><font><font>[1,2,3,]</font></font></code><font><font> 은 마지막에 쉼표가 두 연속 있기 때문에 올바르지 않습니다.</font></font></li> 
 <li><code><font><font>[1,2,3]</font></font></code><font><font> 은 처음에 쉼표가 들어 있기 때문에 올바르지 않습니다.</font></font></li> 
 <li><code><font><font>[1, 2, 3]</font></font></code><font><font> 은 중간에 쉼표가 두 연속 있기 때문에 올바르지 않습니다.</font></font></li> 
 <li><font><font>개체의 필드를 구분 쉼표에 대해서도 비슷한 규칙이 적용됩니다.</font></font></li> 
</ul> 
<!--
### Duplicate keys
--> 
<h3><font><font>중복 키</font></font></h3> 
<!--
The JSON spec does not clarify how duplicate keys in the same object should be handled. In HOCON, duplicate keys that appear later override those that appear earlier, unless both values are objects. If both values are objects, then the objects are merged.
--> 
<p><font><font>JSON의 사양은 동일한 개체의 중복 키 처리는 정의되어 있지 않습니다. </font><font>HOCON는 키가 중복하여 값 중 하나가 개체 그렇지 않으면 나중에 출현하는 것이 먼저 출현하는 것보다 우선합니다. </font><font>값이 모두 객체의 경우, 두 객체가 병합됩니다.</font></font></p> 
<!--
Note: this would make HOCON a non-superset of JSON if you assume that JSON requires duplicate keys to have a behavior. The assumption here is that duplicate keys are invalid JSON.
--> 
<p><font><font>Note : 만약 당신이 JSON에서 키가 중복 된 경우에 어떠한 행동을 나타내는 것을 기대하는 경우 HOCON는 JSON의 상위 집합이 아니라고 말할 수 있습니다. </font><font>여기에 중복 키를 포함 JSON은 잘못된라는 가정을하고 있습니다.</font></font></p> 
<!--
To merge objects:

 - add fields present in only one of the two objects to the merged object.
 - for non-object-valued fields present in both objects, the field found in the second object must be used.
 - for object-valued fields present in both objects, the object values should be recursively merged according to these same rules.
--> 
<p><font><font>개체의 병합은 다음과 같이 이루어집니다.</font></font></p> 
<ul> 
 <li><font><font>두 개체의 한쪽 밖에없는 필드를 병합에 의해 생성되는 새로운 개체에 추가합니다.</font></font></li> 
 <li><font><font>두 개체에 존재하는 모든 "값이 객체가 아닌 필드"에 대한 후자의 개체로 필드를 채용한다.</font></font></li> 
 <li><font><font>두 개체에 존재하는 모든 "값은 객체 필드"에 대한이 세 가지 규칙에 따라 반복적으로 병합한다.</font></font></li> 
</ul> 
<!--
Object merge can be prevented by setting the key to another value first. This is because merging is always done two values at a time; if you set a key to an object, a non-object, then an object, first the non-object falls back to the object (non-object always wins), and then the object falls back to the non-object (no merging, object is the new value). So the two objects never see each other.
--> 
<p><font><font>키에 일단 개체가 아닌 값을 설정하면 두 객체를 병합하지 않을 수도 있습니다. </font><font>이것은 병합이 항상 두 값에 행해지 기 때문입니다. </font><font>예를 들어, 키에 개체, 개체 이외 개체의 순서로 값을 설정하면 먼저 비 개체가 개체를 무시합니다 (항상 비 개체가 우선됩니다). </font><font>그런 다음 개체가 아닌 개체를 덮어합니다 (개체가 키에 대한 새 값입니다. 병합되지 않습니다.) </font><font>따라서 첫 번째와 세 번째의 오브젝트가 병합되지 않습니다.</font></font></p> 
<!--
These two are equivalent:
--> 
<p><font><font>두가지는 동일합니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pun"><font><font>{ </font></font></span><span class="pln">
    </span><span class="str"><font><font>"foo" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"a" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>}, </font></font></span><span class="pln">
    </span><span class="str"><font><font>"foo" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"b" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>43 </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln">
</span><span class="pun"><font><font>}</font></font></span><span class="pln"><font></font>
<font></font>
</span><span class="pun"><font><font>{ </font></font></span><span class="pln">
    </span><span class="str"><font><font>"foo" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"a" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pun"><font><font>, </font></font></span><span class="pln"> </span><span class="str"><font><font>"b" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>43 </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln">
</span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
And these two are equivalent:
--> 
<p><font><font>두가지 모두 동일합니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pun"><font><font>{ </font></font></span><span class="pln">
    </span><span class="str"><font><font>"foo" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"a" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>}, </font></font></span><span class="pln">
    </span><span class="str"><font><font>"foo" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="kwd"><font><font>null </font></font></span><span class="pun"><font><font>, </font></font></span><span class="pln">
    </span><span class="str"><font><font>"foo" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"b" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>43 </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln">
</span><span class="pun"><font><font>}</font></font></span><span class="pln"><font></font>
<font></font>
</span><span class="pun"><font><font>{ </font></font></span><span class="pln">
    </span><span class="str"><font><font>"foo" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"b" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>43 </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln">
</span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
The intermediate setting of `"foo"` to `null` prevents the object merge.
--> 
<p><font><font>보시다시피 중간에 </font></font><code><font><font>"foo"</font></font></code><font><font> 에 </font></font><code><font><font>null</font></font></code><font><font> 를 설정하는 것으로, 개체의 병합을하지 않는다는 것이 가능합니다.</font></font></p> 
<!--
### Paths as keys
--> 
<h3><font><font>키로 경로</font></font></h3> 
<!--
If a key is a path expression with multiple elements, it is expanded to create an object for each path element other than the last. The last path element, combined with the value, becomes a field in the most-nested object.
--> 
<p><font><font>만약 키가 여러 요소로 이루어진 경로 식이면 경로의 마지막 이외의 모든 요소가 전개되고, 객체가 생성됩니다. </font><font>경로의 마지막 요소는 값과 결합되어 가장 안쪽의 개체 필드입니다.</font></font></p> 
<!--
In other words:
--> 
<p><font><font>즉,</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>foo </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>bar </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42</font></font></span></code></pre> 
<!--
is equivalent to:
--> 
<p><font><font>는</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>foo </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>bar </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
and:
--> 
<p><font><font>와 동일하며,</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>foo </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>bar </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>baz </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42</font></font></span></code></pre> 
<!--
is equivalent to:
--> 
<p><font><font>는</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>foo </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>bar </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>baz </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln"> </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<p><font><font>과 같습니다.</font></font></p> 
<!--
and so on. These values are merged in the usual way; which implies that:
--> 
<p><font><font>또한이 값은 위의 방법으로 병합됩니다. </font><font>즉,</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>a </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>x </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pun"><font><font>, </font></font></span><span class="pln"><font><font>a </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>y </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>43</font></font></span></code></pre> 
<!--
is equivalent to:
--> 
<p><font><font>는</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>a </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>x </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pun"><font><font>, </font></font></span><span class="pln"><font><font>y </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>43 </font></font></span><span class="pln"> </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<p><font><font>과 같습니다.</font></font></p> 
<!--
Because path expressions work like value concatenations, you can have whitespace in keys:
--> 
<p><font><font>경로 식은 값의 결합처럼 취급되므로 키 중에 공백을 포함 할 수 있습니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>abc </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42</font></font></span></code></pre> 
<!--
is equivalent to:
--> 
<p><font><font>는</font></font></p> 
<pre class="prettyprint scala"><code><span class="str"><font><font>"ab c ' </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42</font></font></span></code></pre> 
<p><font><font>과 같습니다.</font></font></p> 
<!--
Because path expressions are always converted to strings, even single values that would normally have another type become strings.
--> 
<p><font><font>경로 식은 항상 문자열로 변환되므로 일반적으로 문자열 이외의 형태가되는 것 같은 단일 값조차도 문자열입니다.</font></font></p> 
<!--
   - `true : 42` is `"true" : 42`
   - `3.14 : 42` is `"3.14" : 42`
--> 
<ul> 
 <li><code><font><font>true : 42</font></font></code><font><font> 는 </font></font><code><font><font>"true": 42</font></font></code></li> 
 <li><code><font><font>3.14 : 42</font></font></code><font><font> 는 </font></font><code><font><font>"3.14": 42</font></font></code></li> 
</ul> 
<!--
As a special rule, the unquoted string `include` may not begin a path expression in a key, because it has a special interpretation (see below).
--> 
<p><font><font>특례로서 따옴표를 포함하지 않는 </font></font><code><font><font>include</font></font></code><font><font> 은 특별 취급되기 때문에 키에 경로 식을 포함 할 수 없습니다.</font></font></p> 
<!--
## Substitutions
--> 
<h2><font><font>대체</font></font></h2> 
<!--
Substitutions are a way of referring to other parts of the configuration tree.
--> 
<p><font><font>대체 설정 트리의 다른 부분을 참조하는 기능입니다.</font></font></p> 
<!--
The syntax is `${pathexpression}` or `${?pathexpression}` where the `pathexpression` is a path expression as described above. This path expression has the same syntax that you could use for an object key.
--> 
<p><font><font>대체 문법은 </font></font><code><font><font>$ {pathexpression}</font></font></code><font><font> 또는 </font></font><code><font><font>$ (? pathexpression}</font></font></code><font><font> 입니다. </font></font><code><font><font>pathexpression</font></font></code><font><font> 는 위의 경로 식입니다.이 경로 식은 개체의 키에 사용할 수있는 것과 같은 문법입니다.</font></font></p> 
<!--
The `?` in `${?pathexpression}` must not have whitespace before it; the three characters `${?` must be exactly like that, grouped together.
--> 
<p><code><font><font>$ {? pathexpression}</font></font></code><font><font> 중 </font></font><code><font><font>?</font></font></code><font><font> 는 그 직전에 공백을 포함 할 수 없습니다. </font></font><code><font><font>$ {?</font></font></code><font><font> 라는 세 글자는 전혀이대로 정리해 설명해야합니다.</font></font></p> 
<!--
For substitutions which are not found in the configuration tree, implementations may try to resolve them by looking at system environment variables or other external sources of configuration. (More detail on environment variables in a later section.)
--> 
<p><font><font>설정 트리에없는 대체하려고하면 설정 파일의 구현이 시스템 환경 변수 나 다른 외부 소스의 설정을 참조 해결을 시도합니다. </font><font>(환경 변수에 대한 자세한 내용은 다음 섹션에서 설명합니다.)</font></font></p> 
<!--
Substitutions are not parsed inside quoted strings. To get a string containing a substitution, you must use value concatenation with the substitution in the unquoted portion:
--> 
<p><font><font>인용 문자열은 대체 파싱되지 않습니다. </font><font>교체를 포함한 같은 문자열을 원한다면, 인용되지 않은 부분에 대체 작성하여 값을 결합하는 것이 좋습니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>key </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"><font><font>$ </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>animal </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>favorite </font></font></span><span class="pun"><font><font>} </font></font></span><span class="pln"> </span><span class="kwd"><font><font>is </font></font></span><span class="pln"> </span><span class="kwd"><font><font>my </font></font></span><span class="pln"><font><font>favorite Animal</font></font></span></code></pre> 
<!--
Or you could quote the non-substitution portion:
--> 
<p><font><font>또는 대체 이외의 부분을 따옴표로 둘러싸도 좋습니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>key </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"><font><font>$ </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>animal </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>favorite </font></font></span><span class="pun"><font><font>} </font></font></span><span class="str"><font><font>"is my favorite animal"</font></font></span></code></pre> 
<!--
Substitutions are resolved by looking up the path in the configuration. The path begins with the root configuration object, i.e. it is "absolute" rather than "relative."
--> 
<p><font><font>대체 설정 파일의 경로를 검색하여 해결됩니다. </font><font>이 때 경로는 root 객체에서 시작됩니다. </font><font>즉, 대체에 지정된 경로는 </font></font><code><font><font>상대적</font></font></code><font><font> 보다는 </font></font><code><font><font>절대적</font></font></code><font><font> 입니다.</font></font></p> 
<!--
Substitution processing is performed as the last parsing step, so a substitution can look forward in the configuration. If a configuration consists of multiple files, it may even end up retrieving a value from another file. If a key has been specified more than once, the substitution will always evaluate to its latest-assigned value (the merged object or the last non-object value that was set).
--> 
<p><font><font>교체 작업은 설정 파일 파싱의 마지막 단계에서 실행됩니다. </font><font>따라서 대체 설정 파일의 전방에서 정의 된 경로를 참조 할 수 있습니다. </font><font>만약 설정이 여러 파일로 구성되어있다면, 대체 기술 된 파일은 다른 파일에서 값을 취득하게 될지도 모릅니다. </font><font>키가 여러 번 지정된 경우, 가장 마지막에 설정된 값 (키에 병합 된 개체하거나 혹은 마지막에 설정된 객체가 아닌 값)을 대체하여 삽입되는 것입니다.</font></font></p> 
<!--
If a configuration sets a value to `null` then it should not be looked up in the external source. Unfortunately there is no way to "undo" this in a later configuration file; if you have `{ "HOME" : null }` in a root object, then `${HOME}` will never look at the environment variable. There is no equivalent to JavaScript's `delete` operation in other words.
--> 
<p><font><font>설정은 값에 명시 적으로 </font></font><code><font><font>null</font></font></code><font><font> 이 설정된 경우 값을 외부 소스에서 참조 할 수 없습니다. </font><font>불행히도이 후 설정 파일에서 "undo"하는 방법은 없습니다. </font><font>예를 들어, root 객체에 </font></font><code><font><font>{ "HOME": null}</font></font></code><font><font> 라는 필드를 정의 해 버리면, </font></font><code><font><font>$ {HOME}</font></font></code><font><font> 는 대체 외부 소스 인 환경 변수를 사용하여 해결 될 수는 없습니다. </font><font>즉, JavaScript의 </font></font><code><font><font>delete</font></font></code><font><font> 에 상당하는 조작은 준비되어 있지 않다는 것입니다.</font></font></p> 
<!--
If a substitution does not match any value present in the configuration and is not resolved by an external source, then it is undefined. An undefined substitution with the `${foo}` syntax is invalid and should generate an error.
--> 
<p><font><font>만약 대체하려고 값이 설정 및 외부 소스에 존재하지 않는 경우, 그것은 정의로 처리됩니다. </font></font><code><font><font>$ {foo}</font></font></code><font><font> 는 문법에서 정의되지 않은 대체 허용되지 않기 때문에 오류가 발생합니다.</font></font></p> 
<!--
If a substitution with the `${?foo}` syntax is undefined:
--> 
<p><font><font>한편, </font></font><code><font><font>$ {? foo}</font></font></code><font><font> 라는 문법에 의한 대체가 정의 된 경우,</font></font></p> 
<!--
 - if it is the value of an object field then the field should not
   be created. If the field would have overridden a previously-set
   value for the same field, then the previous value remains.
 - if it is an array element then the element should not be added.
 - if it is part of a value concatenation then it should become an
   empty string.
 - `foo : ${?bar}` would avoid creating field `foo` if `bar` is
   undefined, but `foo : ${?bar} ${?baz}` would be a value
   concatenation so if `bar` or `baz` are not defined, the result
   is an empty string.
--> 
<ul> 
 <li><font><font>만약 객체의 필드 값 이었다면, 필드는 생성되지 않는다. </font><font>이미 필드가 존재하여 이전 값을 덮어 쓰려고했던 경우 정의되지 덮어되지 않고 이전 값이 남아있다.</font></font></li> 
 <li><font><font>만약 배열의 요소 였다면 요소는 추가되지 않는다.</font></font></li> 
 <li><font><font>만약 값의 결합 부분 이었다면, 그 부분은 빈 문자열로 변환된다.</font></font></li> 
 <li><code><font><font>foo : $ {? bar}</font></font></code><font><font> 는 </font></font><code><font><font>bar</font></font></code><font><font> 가 정의되지 않은 경우 필드 </font></font><code><font><font>foo</font></font></code><font><font> 를 작성하지 않는다. </font><font>하지만 </font></font><code><font><font>foo : $ {? bar} $ {? baz}</font></font></code><font><font> 값의 결합이기 때문에 </font></font><code><font><font>bar</font></font></code><font><font> 또는 </font></font><code><font><font>baz</font></font></code><font><font> 가 정의되지 않은 경우 결과는 빈 문자열이된다.</font></font></li> 
</ul> 
<!--
Substitutions are only allowed in object field values and array elements (value concatenations), they are not allowed in keys or nested inside other substitutions (path expressions).
--> 
<p><font><font>대체 객체의 필드 값이나 배열의 요소 (값의 결합)에서만 유효 키 및 기타 대체 (경로 식)에서 사용할 수 없다.</font></font></p> 
<!--
A substitution is replaced with any value type (number, object, string, array, true, false, null). If the substitution is the only part of a value, then the type is preserved. Otherwise, it is value-concatenated to form a string.
--> 
<p><font><font>대체 어떤 값 형식 (number, object, string, array, true, false, null)로 바꿀 수 있습니다. </font><font>대체 값의 일부분 만 있으면 형식이 그대로 유지됩니다. </font><font>그렇지 않으면 값이 결합 된 string입니다.</font></font></p> 
<!--
Circular substitutions are invalid and should generate an error.
--> 
<p><font><font>서로 순환 같은 대체 부정하고, 오류가 발생합니다.</font></font></p> 
<!--
Implementations must take care, however, to allow objects to refer to paths within themselves. For example, this must work:
--> 
<p><font><font>그러나 설정의 파서 구현에서 개체가 자신의 경로를 참조 할 수있게 충분히주의해야합니다. </font><font>예를 들어, 다음 설정은 유효합니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pln"><font><font>bar </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>foo </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pun"><font><font>, </font></font></span><span class="pln"><font><font>
        baz </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"><font><font>$ </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>bar </font></font></span><span class="pun"><font><font>. </font></font></span><span class="pln"><font><font>foo </font></font></span><span class="pun"><font><font>} </font></font></span><span class="pln">
      </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
Here, if an implementation resolved all substitutions in `bar` as part of resolving the substitution `${bar.foo}`, there would be a cycle. The implementation must only resolve the `foo` field in `bar`, rather than recursing the entire `bar` object.
--> 
<p><font><font>이 설정의 대체 </font></font><code><font><font>$ {bar.foo}</font></font></code><font><font> 해결을 위해 </font></font><code><font><font>bar</font></font></code><font><font> 의 모든 치환을 해결할 수있는 파서를 구현했다하면 순환이 발생합니다. </font><font>사실,이 때 </font></font><code><font><font>bar</font></font></code><font><font> 재귀하는 것이 아니라 </font></font><code><font><font>bar</font></font></code><font><font> 의 </font></font><code><font><font>foo</font></font></code><font><font> 필드를 해결하기 같은 파서를 구현해야합니다.</font></font></p> 
<!--
## Includes
--> 
<h2><font><font>포함</font></font></h2> 
<!--
### Include syntax
--> 
<h3><font><font>포함 문법</font></font></h3> 
<!--
An _include statement_ consists of the unquoted string `include` and a single quoted string immediately following it. An include statement can appear in place of an object field.
--> 
<p><em><font><font>include</font></font></em><font><font> 명령은 따옴표로 둘러싸여 있지 </font></font><code><font><font>include</font></font></code><font><font> 라는 문자열과 그 직후에 따옴표로 둘러싸인 문자열의 두 요소로 구성됩니다. </font><font>incude 명령은 객체의 필드 부분에서 설명 할 수 있습니다.</font></font></p> 
<!--
If the unquoted string `include` appears at the start of a path expression where an object key would be expected, then it is not interpreted as a path expression or a key.
--> 
<p><font><font>따옴표 안에 않은 </font></font><code><font><font>include</font></font></code><font><font> 가 경로 식의 시작, 즉 개체의 키가 예상되는 곳에 나타나면 경로 식과 키로 해석되지 않습니다.</font></font></p> 
<!--
Instead, the next value must be a _quoted_ string. The quoted string is interpreted as a filename or resource name to be included.
--> 
<p><font><font>대신 다음 값은 따옴표로 둘러싸인 문자열이어야합니다. </font><font>그 문자열은 포함 된 파일 이름 또는 자원 이름으로 해석됩니다.</font></font></p> 
<!--
Together, the unquoted `include` and the quoted string substitute for an object field syntactically, and are separated from the following object fields or includes by the usual comma (and as usual the comma may be omitted if there's a newline).
--> 
<p><font><font>정리하면, 인용되지 않은 </font></font><code><font><font>include</font></font></code><font><font> 와 인용 된 문자열은 문법적으로는 개체의 필드로 대체됩니다. </font><font>또한 그 뒤에 다른 필드와 새로운 포함 쉼표 (전술대로 줄 바꿈이있는 경우 생략 가능)로 구분 할 수 있습니다.</font></font></p> 
<!--
If an unquoted `include` at the start of a key is followed by anything other than a single quoted string, it is invalid and an error should be generated.
--> 
<p><font><font>인용되지 않은 </font></font><code><font><font>include</font></font></code><font><font> 로 시작하는 키 뒤에 따옴표로 둘러싸인 문자열 이외의 것을 기술 할 것은 틀림에서 오류가 발생합니다.</font></font></p> 
<!--
There can be any amount of whitespace, including newlines, between the unquoted `include` and the quoted string.
--> 
<p><font><font>인용되지 않은 </font></font><code><font><font>include</font></font></code><font><font> 와 인용 된 문자열 사이는 여러개의 공백이나 줄 바꿈을 포함 할 수 있습니다.</font></font></p> 
<!--
Value concatenation is NOT performed on the "argument" to `include`. The argument must be a single quoted string. No substitutions are allowed, and the argument may not be an unquoted string or any other kind of value.
--> 
<p><code><font><font>incude</font></font></code><font><font> 인수에 값의 결합이 작동하지 않습니다. </font><font>인수는 따옴표로 둘러싸인 문자열이어야합니다. </font><font>대체 효과가없고, 인수는 인용되지 않은 문자열 및 기타 값도 사용할 수 없습니다.</font></font></p> 
<!--
Unquoted `include` has no special meaning if it is not the start of a key's path expression.
--> 
<p><font><font>인용되지 않은 </font></font><code><font><font>include</font></font></code><font><font> 는 경로 식의 시작이 아닌 다른 지점에 출현 한 경우는 특별한 의미가 없습니다.</font></font></p> 
<!--
It may appear later in the key:
--> 
<p><font><font>키 후반에 출현하고,</font></font></p> 
<pre class="prettyprint scala"><code><span class="com"><font><font># this is valid </font></font></span><span class="pln">
</span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>foo include </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln">
</span><span class="com"><font><font># equivalent to </font></font></span><span class="pln">
</span><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"foo include" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
It may appear as an object or array value:
--> 
<p><font><font>개체와 배열의 값으로 나타날 수도있을 것이다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>foo </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"><font><font>include </font></font></span><span class="pun"><font><font>} </font></font></span><span class="pln"> </span><span class="com"><font><font># value is the string "include" </font></font></span><span class="pln">
</span><span class="pun"><font><font>[ </font></font></span><span class="pln"><font><font>include </font></font></span><span class="pun"><font><font>] </font></font></span><span class="pln">       </span><span class="com"><font><font># array of one string "include"</font></font></span></code></pre> 
<!--
You can quote `"include"` if you want a key that starts with the word `"include"`, only unquoted `include` is special:
--> 
<p><code><font><font>"include"</font></font></code><font><font> 라는 단어로 시작하는 키가 필요한 경우, </font></font><code><font><font>"include"</font></font></code><font><font> 처럼 따옴표를 붙일 수 있습니다. </font></font><code><font><font>include</font></font></code><font><font> 가 특별한 의미를 갖는 것은 인용되지 않은 때뿐입니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pun"><font><font>{ </font></font></span><span class="pln"> </span><span class="str"><font><font>"include" </font></font></span><span class="pln"> </span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
### Include semantics: merging
--> 
<h3><font><font>포함의 의미 : 병합</font></font></h3> 
<!--
An _including file_ contains the include statement and an _included file_ is the one specified in the include statement. (They need not be regular files on a filesystem, but assume they are for the moment.)
--> 
<p><em><font><font>포함 된 측의 파일</font></font></em><font><font> 은 include 명령과 include 명령에 지정된 </font></font><em><font><font>포함 된 파일</font></font></em><font><font> 의 두 요소로 구성되어 있습니다. </font><font>( </font></font><em><font><font>포함 된 파일</font></font></em><font><font> 은 파일 시스템에있는 파일 일 필요는 없습니다 만, 지금은 그렇게 생각해야합니다)</font></font></p> 
<!--
An included file must contain an object, not an array. This is significant because both JSON and HOCON allow arrays as root values in a document.
--> 
<p><font><font>포함 된 파일은 배열이 아닌 객체를 포함해야합니다. </font><font>일반적으로 JSON과 HOCON이 문서의 root로 배열을 용서하는 것을 생각하면, 포함 된 파일의 root 개체 밖에 허용되지 않는 것은 특징입니다.</font></font></p> 
<!--
If an included file contains an array as the root value, it is invalid and an error should be generated.
--> 
<p><font><font>root로 배열을 가지고 같은 include file 실수로 오류가 발생합니다.</font></font></p> 
<!--
The included file should be parsed, producing a root object. The keys from the root object are conceptually substituted for the include statement in the including file.
--> 
<p><font><font>포함 된 파일이 퍼스되면 root 객체가 생성됩니다. </font><font>개념적으로, root 객체의 키가 포함 된 측의 파일 include 명령으로 대체된다고 생각합니다.</font></font></p> 
<!--
 - If a key in the included object occurred prior to the include
   statement in the including object, the included key's value
   overrides or merges with the earlier value, exactly as with
   duplicate keys found in a single file.
 - If the including file repeats a key from an earlier-included
   object, the including file's value would override or merge
   with the one from the included file.
--> 
<ul> 
 <li><font><font>included object에 포함 된 키가 include 명령 이전에 출현했던 경우 포함 된 키 값은 이전 값을 덮어 쓰거나 이전 값과 병합됩니다. </font><font>덮어와 병합 방법은 단일 파일에 동일한 키를 여러 번 출현 한 경우와 동일합니다.</font></font></li> 
 <li><font><font>이전에 included object에서 가져온 키를 포함하는 측의 파일로 다시 지정하면 포함 된 측의 파일 값이 포함 된 파일의 값을 덮어 쓰거나 병합합니다.</font></font></li> 
</ul> 
<!--
### Include semantics: substitution
--> 
<h3><font><font>포함의 의미 : 대체</font></font></h3> 
<!--
Substitutions in included files are looked up at two different paths; first, relative to the root of the included file; second, relative to the root of the including configuration.
--> 
<p><font><font>포함 된 파일에서 바꾸기는 2 단계에 걸쳐, 각 경로가 다른 해석을 이루어 해결됩니다. </font><font>첫 번째 단계에서는 경로는 포함 된 파일의 root에서 상대적인 것으로 해석됩니다. </font><font>다음 단계는 경로는 포함 된 측의 파일 root에서 상대적인 것으로 해석됩니다.</font></font></p> 
<!--
Recall that substitution happens as a final step, _after_ parsing. It should be done for the entire app's configuration, not for single files in isolation.
--> 
<p><font><font>앞서 언급했듯이, 대체 퍼스 </font></font><em><font><font>후</font></font></em><font><font> 마지막 단계에서 실행됩니다. </font><font>대체 단일 파일의 파일 각각에 대해서가 아니라 응용 프로그램의 전체 구성에 대해 이루어집니다.</font></font></p> 
<!--
Therefore, if an included file contains substitutions, they must be "fixed up" to be relative to the app's configuration root.
--> 
<p><font><font>따라서 included file이 대체를 포함한 경우, 경로는 응용 프로그램 설정 root에서 상대적으로 "수정"되어야합니다.</font></font></p> 
<!--
Say for example that the root configuration is this:
--> 
<p><font><font>예를 들어, 다음과 같은 root 설정이 있다고합니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>a </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>include </font></font></span><span class="str"><font><font>"foo.conf" </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln"> </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
And "foo.conf" might look like this:
--> 
<p><font><font>그리고 다음과 같은 "foo.conf"이 있다고합니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>x </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>10 </font></font></span><span class="pun"><font><font>, </font></font></span><span class="pln"><font><font>y </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"><font><font>$ </font></font></span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>x </font></font></span><span class="pun"><font><font>} </font></font></span><span class="pln"> </span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
If you parsed "foo.conf" in isolation, then `${x}` would evaluate to 10, the value at the path `x`. If you include "foo.conf" in an object at key `a`, however, then it must be fixed up to be `${a.x}` rather than `${x}`.
--> 
<p><font><font>"foo.conf"을 단체로 파싱했다고하면, </font></font><code><font><font>$ {x}</font></font></code><font><font> 는 경로 </font></font><code><font><font>x</font></font></code><font><font> 의 값 10으로 평가 될 것입니다. </font><font>그러나 "foo.conf"어떤 개체의 키 </font></font><code><font><font>a</font></font></code><font><font> 에 포함하면이 경로는 </font></font><code><font><font>$ {x}</font></font></code><font><font> 대신 </font></font><code><font><font>$ {ax}</font></font></code><font><font> 과 같이 수정되어야합니다.</font></font></p> 
<!--
Say that the root configuration redefines `a.x`, like this:
--> 
<p><font><font>또한 root 설정 </font></font><code><font><font>ax</font></font></code><font><font> 가 다음과 같이 다시 정의하는 경우를 생각해 보겠습니다.</font></font></p> 
<pre class="prettyprint scala"><code><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>
    a </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>include </font></font></span><span class="str"><font><font>"foo.conf" </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln"><font><font>
    a </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="pun"><font><font>{ </font></font></span><span class="pln"><font><font>x </font></font></span><span class="pun"><font><font>: </font></font></span><span class="pln"> </span><span class="lit"><font><font>42 </font></font></span><span class="pln"> </span><span class="pun"><font><font>} </font></font></span><span class="pln">
</span><span class="pun"><font><font>}</font></font></span></code></pre> 
<!--
Then the `${x}` in "foo.conf", which has been fixed up to `${a.x}`, would evaluate to `42` rather than to `10`. Substitution happens _after_ parsing the whole configuration.
--> 
<p><font><font>이 때, "foo.conf"의 </font></font><code><font><font>$ {x}</font></font></code><font><font> 는 </font></font><code><font><font>$ {ax}</font></font></code><font><font> 에 수정되어, </font></font><code><font><font>10</font></font></code><font><font> 대신 </font></font><code><font><font>42</font></font></code><font><font> 로 평가됩니다. </font><font>대체 모든 설정 파싱 </font></font><code><font><font>후</font></font></code><font><font> 처리되기 때문입니다.</font></font></p> 
<!--
However, there are plenty of cases where the included file might intend to refer to the application's root config. For example, to get a value from a system property or from the reference configuration. So it's not enough to only look up the "fixed up" path, it's necessary to look up the original path as well.
--> 
<p><font><font>한편, 포함 된 파일에서 의도적으로 응용 프로그램의 root 설정을 참조 할 경우가 많습니다. </font><font>예를 들면 시스템 속성 및 참조 설정에서 값을 검색하는 경우입니다. </font><font>전술 한 바와 같이 "수정"된 경로를 참조하는 것만으로는 불충분하고, 지금 말한 것처럼 원래의 경로를 참조 할 필요가 있습니다.</font></font></p> 
<!--
### Include semantics: missing files
--> 
<h3><font><font>포함의 의미 : 존재하지 않는 파일</font></font></h3> 
<!--
If an included file does not exist, the include statement should be silently ignored (as if the included file contained only an empty object).
--> 
<p><font><font>포함 된 파일이 존재하지 않는 경우, include 명령은 특히 오류없이 무시됩니다 (포함 된 파일에 빈 객체 만 정의되어 있지 않은 경우와 같은 행동입니다).</font></font></p> 
<!--
### Include semantics: locating resources
--> 
<h3><font><font>포함의 의미 : 자원의 특정</font></font></h3> 
<!--
Conceptually speaking, the quoted string in an include statement identifies a file or other resource "adjacent to" the one being parsed and of the same type as the one being parsed. The meaning of "adjacent to", and the string itself, has to be specified separately for each kind of resource.
--> 
<p><font><font>개념적으로는 include 명령의 인수가 될 인용 된 문자열은 그때 파즈 된 파일 및 기타 리소스 "인접"하고, 한편 같은 종류의 자원을 식별하는 데 사용 진행됩니다. </font><font>이 문자열과 "인접"의 의미는 자원의 종류에 따라 다릅니다.</font></font></p> 
<!--
Implementations may vary in the kinds of resources they support including.
--> 
<p><font><font>설정 파서의 구현을 통해 지원하는 자원의 종류에 차이가있을 수 있습니다.</font></font></p> 
<!--
On the Java Virtual Machine, if an include statement does not identify anything "adjacent to" the including resource, implementations may wish to fall back to a classpath resource. This allows configurations found in files or URLs to access classpath resources.
--> 
<p><font><font>Java Virtual Machine에서는 include 명령이 포함 된 것으로 "인접"자원이라는 것을 찾을 수없는 경우, 파서의 구현은 클래스 패스에있는 자원으로 대체 할 수있다로되어 있습니다. </font><font>이 규칙 덕분에 파일 시스템이나 URL의 설정 파일에서 클래스 패스의 자원을 참조 할 수 있습니다.</font></font></p> 
<!--
For resources located on the Java classpath:
--> 
<p><font><font>Java의 클래스 패스에있는 자원은</font></font></p> 
<!--
 - included resources are looked up by calling `getResource()` on
   the same class loader used to look up the including resource.
 - if the included resource name is absolute (starts with '/')
   then it should be passed to `getResource()` with the '/'
   removed.
 - if the included resource name does not start with '/' then it
   should have the "directory" of the including resource.
   prepended to it, before passing it to `getResource()`.  If the
   including resource is not absolute (no '/') and has no "parent
   directory" (is just a single path element), then the included
   relative resource name should be left as-is.
 - it would be wrong to use `getResource()` to get a URL and then
   locate the included name relative to that URL, because a class
   loader is not required to have a one-to-one mapping between
   paths in its URLs and the paths it handles in `getResource()`.
   In other words, the "adjacent to" computation should be done
   on the resource name not on the resource's URL.
--> 
<ul> 
 <li><font><font>포함 된 리소스는 포함 된 측의 리소스를 검색하는 데 사용 된 것과 동일한 클래스 로더의 </font></font><code><font><font>getResource ()</font></font></code><font><font> 메서드를 호출하여 검색됩니다.</font></font></li> 
 <li><font><font>포함 된 리소스의 이름이 절대 경로 ( '/'로 시작) 인 경우는 '/'를 삭제 한 다음 </font></font><code><font><font>getResource ()</font></font></code><font><font> 에 전달됩니다.</font></font></li> 
 <li><font><font>포함 된 리소스의 이름이 '/'로 시작하지 않으면, 포함 된 측의 리소스 디렉토리를 선두로 연결해에서 </font></font><code><font><font>getResource ()</font></font></code><font><font> 에 전달합니다. </font><font>포함 된 측 리소스 이름이 절대 경로가 아닌 ( '/'로 시작하지 않는), 그리고 "부모 디렉토리"(단순한 경로 요소)도없는 경우 포함 된 상대적인 리소스 이름이 그대로 사용됩니다.</font></font></li> 
 <li><code><font><font>getResource ()</font></font></code><font><font> 를 URL을 얻거나 또는 URL에서 포함 된 리소스의 상대 URL을 얻기 위해 사용하는 것은 실수입니다. </font><font>이 클래스 로더의 URL의 경로와 </font></font><code><font><font>getResource ()</font></font></code><font><font> 의 경로 일대일 매핑을한다고는 할 수 없기 때문입니다. </font><font>즉, 위의 "이웃"의 계산은 자원의 URL 대신 이름을 사용하여 수행해야한다는 것입니다.</font></font></li> 
</ul> 
<!--
For plain files on the filesystem:
--> 
<p><font><font>파일 시스템의 파일 내용은</font></font></p> 
<!--
 - if the included file is an absolute path then it should be kept
   absolute and loaded as such.
 - if the included file is a relative path, then it should be
   located relative to the directory containing the including
   file.  The current working directory of the process parsing a
   file must NOT be used when interpreting included paths.
 - if the file is not found, fall back to the classpath resource.
   The classpath resource should not have any package name added
   in front, it should be relative to the "root"; which means any
   leading "/" should just be removed (absolute is the same as
   relative since it's root-relative). The "/" is handled for
   consistency with including resources from inside other
   classpath resources, where the resource name may not be
   root-relative and "/" allows specifying relative to root.
--> 
<ul> 
 <li><font><font>포함 된 파일을 절대 경로는 절대 경로대로 처리하여로드됩니다.</font></font></li> 
 <li><font><font>포함 된 파일이 상대 경로의 경우, 포함하는 측의 파일에 상대적으로 해석됩니다. </font><font>포함 된 경로를 해석 할 때, 파일을 해석하는 프로세스의 현재 디렉토리를 사용해서는 안됩니다.</font></font></li> 
 <li><font><font>파일을 찾을 수없는 경우, 클래스 패스의 자원으로 대체합니다. </font><font>그 때, 클래스 패스의 리소스 이름 앞에 패키지 이름을 추가하는 것은하지 않고, "root"에서 상대 경로입니다. </font><font>이것은 첫 번째 "/"이 단지 삭제된다 (이번에는 root에 상대적이므로이 규칙은 절대 경로를 상대 경로 같은 리소스를 가리키는 것입니다)을 의미합니다. </font><font>"/"를 이렇게 취급 이유는 다른 클래스 아빠스 자원 내에서 리소스를 포함하는 경우와 일관성 때문입니다. </font><font>그 경우에는 리소스 이름은 root에서 상대 경로가 아닌 "/"를 붙이는 것으로 root에서 상대 경로입니다.</font></font></li> 
</ul> 
<!--
URLs:
--> 
<p><font><font>URL은</font></font></p> 
<!--
 - for both filesystem files and Java resources, if the
   included name is a URL (begins with a protocol), it would
   be reasonable behavior to try to load the URL rather than
   treating the name as a filename or resource name.
 - for files loaded from a URL, "adjacent to" should be based
   on parsing the URL's path component, replacing the last
   path element with the included name.
 - file: URLs should behave in exactly the same way as a plain
   filename
--> 
<ul> 
 <li><font><font>파일 시스템에있는 파일과 Java 자원에 대해 모두 포함 된 이름이 URL (프로토콜 이름으로 시작)의 경우, 이름은 파일 이름과 자원 이름이 아닌 URL로 해석로드 될 것이다.</font></font></li> 
 <li><font><font>URL에서로드 된 파일은 "인접"는 URL의 경로 부분을 해석하여 최종 요소를 포함 된 이름으로 대체하여 계산됩니다.</font></font></li> 
 <li><font><font>file : 프로토콜 URL이 지정된 경우 단순한 파일 이름이 지정된 경우와 같은 행동입니다.</font></font></li> 
</ul> 
<!--
## Duration format
--> 
<h2><font><font>기간 지정 용 포맷</font></font></h2> 
<!--
The supported unit strings for duration are case sensitive and must be lowercase. Exactly these strings are supported:
--> 
<p><font><font>기간 지정에 사용하는 단위 시간을 나타내는 문자열은 대소 문자 구분하며 모든 소문자로되어야합니다. </font><font>다음 문자열을 지원합니다.</font></font></p> 
<ul> 
 <li><code><font><font>ns</font></font></code><font><font> , </font></font><code><font><font>nanosecond</font></font></code><font><font> , </font></font><code><font><font>nanoseconds</font></font></code></li> 
 <li><code><font><font>us</font></font></code><font><font> , </font></font><code><font><font>microsecond</font></font></code><font><font> , </font></font><code><font><font>microseconds</font></font></code></li> 
 <li><code><font><font>ms</font></font></code><font><font> , </font></font><code><font><font>millisecond</font></font></code><font><font> , </font></font><code><font><font>milliseconds</font></font></code></li> 
 <li><code><font><font>s</font></font></code><font><font> , </font></font><code><font><font>second</font></font></code><font><font> , </font></font><code><font><font>seconds</font></font></code></li> 
 <li><code><font><font>m</font></font></code><font><font> , </font></font><code><font><font>minute</font></font></code><font><font> , </font></font><code><font><font>minutes</font></font></code></li> 
 <li><code><font><font>h</font></font></code><font><font> , </font></font><code><font><font>hour</font></font></code><font><font> , </font></font><code><font><font>hours</font></font></code></li> 
 <li><code><font><font>d</font></font></code><font><font> , </font></font><code><font><font>day</font></font></code><font><font> , </font></font><code><font><font>days</font></font></code></li> 
</ul> 
<!--
## Size in bytes format
--> 
<h2><font><font>크기 바이트 지정 용 포맷</font></font></h2> 
<!--
For single bytes, exactly these strings are supported:
--> 
<p><font><font>바이트는 다음 문자열을 지원합니다.</font></font></p> 
<ul> 
 <li><code><font><font>B</font></font></code><font><font> , </font></font><code><font><font>b</font></font></code><font><font> , </font></font><code><font><font>byte</font></font></code><font><font> , </font></font><code><font><font>bytes</font></font></code></li> 
</ul> 
<!--
For powers of ten, exactly these strings are supported:
--> 
<p><font><font>10의 제곱은 다음 문자열을 지원합니다.</font></font></p> 
<ul> 
 <li><code><font><font>kB</font></font></code><font><font> , </font></font><code><font><font>kilobyte</font></font></code><font><font> , </font></font><code><font><font>kilobytes</font></font></code></li> 
 <li><code><font><font>MB</font></font></code><font><font> , </font></font><code><font><font>megabyte</font></font></code><font><font> , </font></font><code><font><font>megabytes</font></font></code></li> 
 <li><code><font><font>GB</font></font></code><font><font> , </font></font><code><font><font>gigabyte</font></font></code><font><font> , </font></font><code><font><font>gigabytes</font></font></code></li> 
 <li><code><font><font>TB</font></font></code><font><font> , </font></font><code><font><font>terabyte</font></font></code><font><font> , </font></font><code><font><font>terabytes</font></font></code></li> 
 <li><code><font><font>PB</font></font></code><font><font> , </font></font><code><font><font>petabyte</font></font></code><font><font> , </font></font><code><font><font>petabytes</font></font></code></li> 
 <li><code><font><font>EB</font></font></code><font><font> , </font></font><code><font><font>exabyte</font></font></code><font><font> , </font></font><code><font><font>exabytes</font></font></code></li> 
 <li><code><font><font>ZB</font></font></code><font><font> , </font></font><code><font><font>zettabyte</font></font></code><font><font> , </font></font><code><font><font>zettabytes</font></font></code></li> 
 <li><code><font><font>YB</font></font></code><font><font> , </font></font><code><font><font>yottabyte</font></font></code><font><font> , </font></font><code><font><font>yottabytes</font></font></code></li> 
</ul> 
<!--
For powers of two, exactly these strings are supported:
--> 
<p><font><font>2의 거듭 제곱은 다음 문자열을 지원합니다.</font></font></p> 
<ul> 
 <li><code><font><font>K</font></font></code><font><font> , </font></font><code><font><font>k</font></font></code><font><font> , </font></font><code><font><font>Ki</font></font></code><font><font> , </font></font><code><font><font>KiB</font></font></code><font><font> , </font></font><code><font><font>kibibyte</font></font></code><font><font> , </font></font><code><font><font>kibibytes</font></font></code></li> 
 <li><code><font><font>M</font></font></code><font><font> , </font></font><code><font><font>m</font></font></code><font><font> , </font></font><code><font><font>Mi</font></font></code><font><font> , </font></font><code><font><font>MiB</font></font></code><font><font> , </font></font><code><font><font>mebibyte</font></font></code><font><font> , </font></font><code><font><font>mebibytes</font></font></code></li> 
 <li><code><font><font>G</font></font></code><font><font> , </font></font><code><font><font>g</font></font></code><font><font> , </font></font><code><font><font>Gi</font></font></code><font><font> , </font></font><code><font><font>GiB</font></font></code><font><font> , </font></font><code><font><font>gibibyte</font></font></code><font><font> , </font></font><code><font><font>gibibytes</font></font></code></li> 
 <li><code><font><font>T</font></font></code><font><font> , </font></font><code><font><font>t</font></font></code><font><font> , </font></font><code><font><font>Ti</font></font></code><font><font> , </font></font><code><font><font>TiB</font></font></code><font><font> , </font></font><code><font><font>tebibyte</font></font></code><font><font> , </font></font><code><font><font>tebibytes</font></font></code></li> 
 <li><code><font><font>P</font></font></code><font><font> , </font></font><code><font><font>p</font></font></code><font><font> , </font></font><code><font><font>Pi</font></font></code><font><font> , </font></font><code><font><font>PiB</font></font></code><font><font> , </font></font><code><font><font>pebibyte</font></font></code><font><font> , </font></font><code><font><font>pebibytes</font></font></code></li> 
 <li><code><font><font>E</font></font></code><font><font> , </font></font><code><font><font>e</font></font></code><font><font> , </font></font><code><font><font>Ei</font></font></code><font><font> , </font></font><code><font><font>EiB</font></font></code><font><font> , </font></font><code><font><font>exbibyte</font></font></code><font><font> , </font></font><code><font><font>exbibytes</font></font></code></li> 
 <li><code><font><font>Z</font></font></code><font><font> , </font></font><code><font><font>z</font></font></code><font><font> , </font></font><code><font><font>Zi</font></font></code><font><font> , </font></font><code><font><font>ZiB</font></font></code><font><font> , </font></font><code><font><font>zebibyte</font></font></code><font><font> , </font></font><code><font><font>zebibytes</font></font></code></li> 
 <li><code><font><font>Y</font></font></code><font><font> , </font></font><code><font><font>y</font></font></code><font><font> , </font></font><code><font><font>Yi</font></font></code><font><font> , </font></font><code><font><font>YiB</font></font></code><font><font> , </font></font><code><font><font>yobibyte</font></font></code><font><font> , </font></font><code><font><font>yobibytes</font></font></code></li> 
</ul> 
<!--
## Conventional override by system properties
--> 
<h2><font><font>관습으로 시스템 속성에 의한 덮어</font></font></h2> 
<!--
For an application's config, Java system properties _override_ settings found in the configuration file. This supports specifying config options on the command line.
--> 
<p><font><font>응용 프로그램 설정에서 Java 시스템 속성은 설정 파일에 기술 된 설정을 </font></font><em><font><font>덮어</font></font></em><font><font> 합니다. </font><font>따라서 옵션을 명령 줄에서 지정할 수 있습니다.</font></font></p>
    </article>
    <aside>
    <h3><font><font>공식 문서</font></font></h3>
        <p>
            <a href="http://www.playframework.org/documentation/2.0.3/Configuration" target="_blank"><font><font>Documentation : Configuration - Playframework</font></font></a>
        </p>
                <h3><font><font>설정</font></font></h3> 
<!--
- [[Configuration file syntax and features | Configuration]]
- [[Configuring the JDBC connection pool | SettingsJDBC]]
- [[Configuring the internal Akka system | AkkaCore]]
- [[Configuring logging | SettingsLogger]]
--> 
<ul> 
 <li><a href="./configuration.html"><font><font>설정 파일의 구문과 기능</font></font></a></li> 
 <li><a href="./SettingsJDBC.html"><font><font>JDBC 연결 풀 구성</font></font></a></li> 
 <li><a href="./AkkaCore.html"><font><font>내부 Akka 시스템 설정</font></font></a></li> 
 <li><a href="./SettingsLogger.html"><font><font>로그 설정</font></font></a></li> 
</ul> 
<!--
### Getting started
-->
<h3><font><font>소개</font></font></h3> 
<!--
- [[Installing Play 2.0 | Installing]]
- [[Creating a new application | NewApplication]]
- [[Anatomy of a Play 2.0 application | Anatomy]]
- [[Using the Play 2.0 console | PlayConsole ]]
- [[Setting-up your preferred IDE | IDE]]
- [[Sample applications | Samples]]
--> 
 <ul> 
 <li><a href="../installing.html"><font><font>Play 2.0 설치</font></font></a></li> 
 <li><a href="../newapplication.html"><font><font>새 응용 프로그램을 만들</font></font></a></li> 
 <li><a href="../anatomy.html"><font><font>Play 2.0 응용 프로그램의 구조</font></font></a></li> 
 <li><a href="../playconsole.html"><font><font>Play 2.0 콘솔을 사용</font></font></a></li> 
 <li><a href="../ide.html"><font><font>좋아하는 IDE에서 개발하는</font></font></a></li> 
 <li><a href="../samples.html"><font><font>샘플 응용 프로그램</font></font></a></li> 
</ul> 
<!--
### Working with Play 2.0
-->
<h3><font><font>Play 2.0 개발</font></font></h3> 
<!--
- [[Play 2.0 for Scala developers | ScalaHome]]
- [[Play 2.0 for Java developers | JavaHome]]
--> 
<ul> 
 <li><a href="../scaladocs/scalahome.html"><font><font>Scala 개발자를위한 Play 2.0</font></font></a></li> 
 <li><a href="../javadocs/javahome.html"><font><font>Java 개발자를위한 Play 2.0</font></font></a></li> 
</ul> 
<!--
### Detailed topics
-->
<h3><font><font>자세한 주제</font></font></h3> 
<!--
- [[The Build system | Build]]
- [[Working with public assets | Assets]]
- [[Managing database evolutions | Evolutions]]
- [[Configuration file syntax and features | Configuration]]
- [[Deploying your application | Production]]
--> 
<ul> 
 <li><a href="../build/build.html"><font><font>빌드 시스템</font></font></a></li> 
 <li><a href="../assets/assets.html"><font><font>공개 에셋을 사용</font></font></a></li> 
 <li><a href="../evolutions/evolutions.html"><font><font>Evolutions에서 데이터베이스 관리</font></font></a></li> 
 <li><a href="../configuration/configuration.html"><font><font>설정 파일의 구문과 기능</font></font></a></li> 
 <li><a href="../production/production.html"><font><font>응용 프로그램 배포</font></font></a></li> 
</ul> 
<!--
### Additional documentation
-->
<h3><font><font>기타 문서</font></font></h3> 
<ul> 
 <li><a href="http://docs.scala-lang.org/"><font><font>Scala</font></font></a></li> 
 <li><a href="http://akka.io/docs/"><font><font>Akka</font></font></a></li> 
 <li><a href="http://www.scala-sbt.org/learn.html"><font><font>sbt</font></font></a></li> 
 <li><a href="https://github.com/typesafehub/config"><font><font>Configuration</font></font></a></li> 
 <li><a href="http://logback.qos.ch/documentation.html"><font><font>Logback</font></font></a></li> 
</ul>
                        <h3><font><font>도서</font></font></h3>
                        <p><a title="Play for Scala" href="http://bit.ly/playscala"><img src="../images/play-for-scala-cover.jpg"></a></p>
        <p><a title="Play for Java" href="http://bit.ly/playjava"><img src="../images/play-for-java-cover.jpg"></a></p>
               
    </aside>
</div>
        <footer>
            <img class="logo" src="../images/logo-footer.png">
            <div class="links">
                <dl>
                    <dt><font><font>Play</font></font></dt>
                    <dd><a href="http://www.playframework.org/download"><font><font>Downloads</font></font></a></dd>
                    <dd><a href="http://www.playframework.org/documentation/latest"><font><font>Documentation</font></font></a></dd>
                    <dd><a href="http://www.apache.org/licenses/LICENSE-2.0.html"><font><font>License</font></font></a></dd>
                </dl>
                <dl>
                    <dt><font><font>Contribute</font></font></dt>
                    <dd><a href="http://github.com/playframework/Play20"><font><font>Source code</font></font></a></dd>
                    <dd><a href="https://groups.google.com/forum/#!forum/play-framework"><font><font>Mailling list</font></font></a></dd>
                    <dd><a href="https://play.lighthouseapp.com/dashboard"><font><font>Bug tracker</font></font></a></dd>
                </dl>
                <dl>
                    <dt><font><font>Ecosystem</font></font></dt>
                    <dd><a href="http://www.playframework.org/code/team" target="_blank"><font><font>Team &amp; contributors</font></font></a></dd>
                    <dd><a href="http://typesafe.com/stack"><font><font>Commercial support</font></font></a></dd>
                    <dd><a href="http://www.playframework.org/modules" target="_blank"><font><font>Modules</font></font></a></dd>
                </dl>
            </div>
            <div class="licence"><font><font>
                play Framework is Released 신청 the </font></font><a href="http://www.apache.org/licenses/LICENSE-2.0.html"><font><font>아파치 2 License</font></font></a>
                <a class="typesafe" href="http://typesafe.com/"><img src="../images/typesafe.png"></a>
                <a class="zenexity" href="http://zenexity.com/"><img src="../images/zenexity.png"></a>
            </div>
        </footer>
</body></html>